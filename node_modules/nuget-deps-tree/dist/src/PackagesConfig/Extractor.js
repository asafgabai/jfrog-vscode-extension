"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackagesExtractor = void 0;
const exec = __importStar(require("child_process"));
const fse = __importStar(require("fs-extra"));
const loglevel_1 = __importDefault(require("loglevel"));
const pathUtils = __importStar(require("path"));
const model_1 = require("../../model");
const CommonUtils_1 = require("../CommonUtils");
const Utils_1 = require("../DependencyTree/Utils");
const Dependency_1 = require("../Structure/Dependency");
const NugetPackage_1 = require("./NugetPackage");
const packagesFileName = 'packages.config';
class PackagesExtractor {
    constructor(_allDependencies, _childrenMap) {
        this._allDependencies = _allDependencies;
        this._childrenMap = _childrenMap;
    }
    /**
     * Get map of all the dependencies of the project.
     * @returns map of lower cased dependencies IDs and their actual details.
     */
    allDependencies() {
        return this._allDependencies;
    }
    /**
     * Get array of all the root dependencies of the project.
     * @returns array of the lower cased IDs of all root dependencies
     */
    directDependencies() {
        return this.getDirectDependencies(this._allDependencies, this._childrenMap);
    }
    /**
     * Get map of the dependencies relations map.
     * @returns map of lower cased dependencies IDs and an array of their lower cased dependencies IDs
     */
    childrenMap() {
        return this._childrenMap;
    }
    /**
     * Checks if the project's dependencies source is of packages config type.
     * @param projectName
     * @param dependenciesSource
     * @returns true if compatible
     */
    static isCompatible(projectName, dependenciesSource) {
        if (dependenciesSource.endsWith(packagesFileName)) {
            loglevel_1.default.debug('Found', dependenciesSource, 'file for project:', projectName);
            return true;
        }
        return false;
    }
    /**
     * Create new package config extractor.
     * @param dependenciesSource
     * @returns packages config extractor
     */
    static newExtractor(dependenciesSource) {
        const newPkgExtractor = new PackagesExtractor(new model_1.CaseInsensitiveMap(), new model_1.CaseInsensitiveMap());
        const packagesConfig = newPkgExtractor.loadPackagesConfig(dependenciesSource);
        const globalPackagesCache = newPkgExtractor.getGlobalPackagesCache();
        newPkgExtractor.extract(packagesConfig, globalPackagesCache);
        return newPkgExtractor;
    }
    /**
     * Get direct dependencies using DFS on all dependencies and children map.
     * @param allDependencies
     * @param childrenMap
     * @returns array of the ids' of all root dependencies
     */
    getDirectDependencies(allDependencies, childrenMap) {
        var _a;
        const helper = new model_1.CaseInsensitiveMap();
        for (const id of allDependencies.keys()) {
            helper.set(id, new DfsHelper(false, false, false));
        }
        for (const id of allDependencies.keys()) {
            if ((_a = helper.get(id)) === null || _a === void 0 ? void 0 : _a.visited) {
                continue;
            }
            this.searchRootDependencies(helper, id, allDependencies, childrenMap, new model_1.CaseInsensitiveMap([[id, true]]));
        }
        const rootDependencies = [];
        helper.forEach((nodeData, id) => {
            if (!nodeData.notRoot || nodeData.circular) {
                rootDependencies.push(id);
            }
        });
        return rootDependencies;
    }
    /**
     * Search for root dependencies and update maps accordingly.
     * @param dfsHelper
     * @param currentId
     * @param allDependencies
     * @param childrenMap
     * @param traversePath
     */
    searchRootDependencies(dfsHelper, currentId, allDependencies, childrenMap, traversePath) {
        var _a;
        if ((_a = dfsHelper.get(currentId)) === null || _a === void 0 ? void 0 : _a.visited) {
            return;
        }
        const children = childrenMap.get(currentId);
        if (children && children.length > 0) {
            for (const next of children) {
                if (!allDependencies.get(next)) {
                    // No such dependency.
                    continue;
                }
                if (traversePath.get(next)) {
                    for (const circular of traversePath.keys()) {
                        const circularDfs = this.getDfs(dfsHelper, circular);
                        circularDfs.circular = true;
                    }
                    continue;
                }
                // Not root dependency.
                const noRootDfs = this.getDfs(dfsHelper, next);
                noRootDfs.notRoot = true;
                traversePath.set(next, true);
                this.searchRootDependencies(dfsHelper, next, allDependencies, childrenMap, traversePath);
                traversePath.delete(next);
            }
        }
        const visitedDfs = this.getDfs(dfsHelper, currentId);
        visitedDfs.visited = true;
        return;
    }
    /**
     * Get dfs helper for requested key.
     * @param dfsHelper
     * @param key
     * @returns dfs helper.
     */
    getDfs(dfsHelper, key) {
        let dfs = dfsHelper.get(key);
        if (!dfs) {
            dfs = new DfsHelper(false, false, false);
            dfsHelper.set(key, dfs);
        }
        return dfs;
    }
    /**
     * Extract all the extractor's needed dependencies map from the packages config file.
     * @param packagesConfig
     * @param globalPackagesCache
     */
    extract(packagesConfig, globalPackagesCache) {
        const packages = CommonUtils_1.CommonUtils.getPropertyOrUndefined(packagesConfig, 'packages[0].package');
        for (const nuget of packages) {
            const id = nuget.id;
            const version = nuget.version;
            // First lets check if the original version exists within the file system:
            let pack = this.createNugetPackage(globalPackagesCache, id, version);
            if (!pack) {
                // If doesn't exist lets build the array of alternative versions.
                const alternativeVersions = this.createAlternativeVersionForms(version);
                // Now lets do a loop to run over the alternative possibilities.
                for (const v of alternativeVersions) {
                    pack = this.createNugetPackage(globalPackagesCache, id, v);
                    if (pack) {
                        break;
                    }
                }
            }
            if (pack) {
                this._allDependencies.set(id, new Dependency_1.Dependency(id, version));
                this._childrenMap.set(id, Array.from(pack.dependencies.keys()));
            }
            else {
                loglevel_1.default.warn('The following NuGet package %s with version %s was not found in the NuGet cache %s.' +
                    Utils_1.absentNupkgWarnMsg, nuget.id, nuget.version, globalPackagesCache);
            }
        }
    }
    /**
     * Creates a nuget package if found in cache in the requested version.
     * @param packagesPath - Path to global packages cache.
     * @param packageId - Requested package id.
     * @param packageVersion - Requested package version.
     * @returns A nuget package, or undefined if not found in cache.
     */
    createNugetPackage(packagesPath, packageId, packageVersion) {
        // Nuspec file that holds the metadata for the package. Id in path is lower cased.
        const nuspecPath = pathUtils.join(packagesPath, packageId.toLowerCase(), packageVersion, [packageId.toLowerCase(), 'nuspec'].join('.'));
        // File does not exist for package with that version.
        if (!fse.pathExistsSync(nuspecPath)) {
            return undefined;
        }
        const nuspecContent = CommonUtils_1.CommonUtils.readFileIfExists(nuspecPath);
        if (!nuspecContent) {
            throw new Error('Unable to read file: ' + nuspecPath);
        }
        return new NugetPackage_1.NugetPackage(packageId, packageVersion, nuspecContent);
    }
    /**
     * NuGet allows the version to be with missing or unnecessary zeros.
     * This method generates an array of the possible alternative versions.
     * For example:
     * "1.0" --> []string{"1.0.0.0", "1.0.0", "1"}
     * "1" --> []string{"1.0.0.0", "1.0.0", "1.0"}
     * "1.2" --> []string{"1.2.0.0", "1.2.0"}
     * "1.22.33" --> []string{"1.22.33.0"}
     * "1.22.33.44" --> []string{}
     * "1.0.2" --> []string{"1.0.2.0"}
     * @param originalVersion - version listed in the packages config file.
     * @returns array of possible alternative versions.
     */
    createAlternativeVersionForms(originalVersion) {
        const versionsSlice = originalVersion.split('.');
        for (let i = 4; i > versionsSlice.length; i--) {
            versionsSlice.push('0');
        }
        const alternativeVersions = [];
        for (let i = 4; i > 0; i--) {
            const version = versionsSlice.slice(0, i).join('.');
            if (version !== originalVersion) {
                alternativeVersions.push(version);
            }
            if (!version.endsWith('.0')) {
                return alternativeVersions;
            }
        }
        return alternativeVersions;
    }
    /**
     * Load packages config data, by reading the xml file and parsing.
     * @param dependenciesSource.
     * @returns packages config object.
     */
    loadPackagesConfig(dependenciesSource) {
        const content = CommonUtils_1.CommonUtils.readFileIfExists(dependenciesSource);
        if (!content) {
            throw new Error('Unable to read file: ' + dependenciesSource);
        }
        return CommonUtils_1.CommonUtils.parseXmlToObject(content);
    }
    /**
     * Get global packages cache path.
     * @returns path to cache.
     */
    getGlobalPackagesCache() {
        const output = this.runGlobalPackagesCommand();
        const globalPackagesPath = this.removeGlobalPackagesPrefix(output);
        if (!fse.pathExists(globalPackagesPath)) {
            throw new Error('Could not find global packages path at: ' + globalPackagesPath);
        }
        return globalPackagesPath;
    }
    /**
     * Removes prefix from global packages command.
     * @param line - output of the command.
     * @returns - output after removing prefix.
     */
    removeGlobalPackagesPrefix(line) {
        return line.replace(/^global-packages:/, '').trim();
    }
    /**
     * Run global packages command.
     * @returns command output.
     */
    runGlobalPackagesCommand() {
        let cmd = this.getExecutablePath();
        cmd += ' locals global-packages -list';
        let output = '';
        try {
            output = exec.execSync(cmd, { maxBuffer: 10485760 }).toString();
        }
        catch (error) {
            throw new Error("Running '" + cmd + "' failed with error: " + error);
        }
        return output;
    }
    /**
     * Get path of executable suitable for running the command, according to the operating system.
     */
    getExecutablePath() {
        if (CommonUtils_1.CommonUtils.isWindows()) {
            return CommonUtils_1.CommonUtils.lookPath('nuget');
        }
        return this.getNonWindowsExecutablePath();
    }
    /**
     * NuGet can be run on non Windows OS in one of the following ways:
     * 1. using nuget client
     * 2. using Mono
     */
    getNonWindowsExecutablePath() {
        const nugetPath = CommonUtils_1.CommonUtils.lookPath('nuget');
        if (nugetPath) {
            return nugetPath;
        }
        // If 'nuget' wasn't found, we Will try to run nuget using mono.
        // Mono's first argument is nuget.exe's path, so we will look for both mono and nuget.exe in PATH.
        const monoPath = CommonUtils_1.CommonUtils.lookPath('mono');
        const nugetExePath = CommonUtils_1.CommonUtils.lookPath('nuget.exe');
        if (!monoPath || !nugetExePath) {
            throw new Error('could neither find nuget client path, nor mono and nuget executable path');
        }
        return monoPath + ' ' + nugetExePath;
    }
}
exports.PackagesExtractor = PackagesExtractor;
class DfsHelper {
    constructor(_visited, _notRoot, _circular) {
        this._visited = _visited;
        this._notRoot = _notRoot;
        this._circular = _circular;
    }
    get circular() {
        return this._circular;
    }
    set circular(value) {
        this._circular = value;
    }
    get notRoot() {
        return this._notRoot;
    }
    set notRoot(value) {
        this._notRoot = value;
    }
    get visited() {
        return this._visited;
    }
    set visited(value) {
        this._visited = value;
    }
}
//# sourceMappingURL=Extractor.js.map