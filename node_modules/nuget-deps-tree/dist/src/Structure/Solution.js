"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Solution = void 0;
const fs = __importStar(require("fs"));
const loglevel_1 = __importDefault(require("loglevel"));
const pathUtils = __importStar(require("path"));
const walkdir = __importStar(require("walkdir"));
const CommonUtils_1 = require("../CommonUtils");
const Project_1 = require("./Project");
const packagesFileName = 'packages.config';
const assetsFileName = 'project.assets.json';
class Solution {
    constructor(_filePath, _projects = [], _dependenciesSources = []) {
        this._filePath = _filePath;
        this._projects = _projects;
        this._dependenciesSources = _dependenciesSources;
    }
    get filePath() {
        return this._filePath;
    }
    set filePath(value) {
        this._filePath = value;
    }
    get projects() {
        return this._projects;
    }
    set projects(value) {
        this._projects = value;
    }
    get dependenciesSources() {
        return this._dependenciesSources;
    }
    set dependenciesSources(value) {
        this._dependenciesSources = value;
    }
    /**
     * Create a solution object with projects and dependencies sources,
     * which will later be used to generate dependencies trees.
     * @param slnFilePath
     * @returns the solution object
     */
    static create(slnFilePath) {
        const sln = new Solution(slnFilePath);
        sln.getDependenciesSources(slnFilePath);
        sln.loadProjects();
        return sln;
    }
    /**
     * Recursively walk through the file system to find all potential dependencies sources:
     * packages.config and project.assets.json files.
     * @param slnFilePath
     */
    getDependenciesSources(slnFilePath) {
        const curDependenciesSources = [];
        walkdir.find(pathUtils.parse(slnFilePath).dir, { follow_symlinks: true, sync: true }, (path) => {
            if (path.endsWith(packagesFileName) || path.endsWith(assetsFileName)) {
                curDependenciesSources.push(pathUtils.resolve(path));
                loglevel_1.default.debug('found: ', path);
            }
        });
        // Sort by length ascending.
        curDependenciesSources.sort((a, b) => {
            return a.length - b.length;
        });
        this._dependenciesSources.push(...curDependenciesSources);
    }
    /**
     * Loads projects from solution file.
     * If there are none, a single project is expected to be found in the solution directory.
     */
    loadProjects() {
        const projectsDeclarations = this.parseSlnFile();
        if (projectsDeclarations.length > 0) {
            this.loadProjectsFromSolutionFile(projectsDeclarations);
            return;
        }
        this.loadSingleProjectFromDir();
    }
    loadProjectsFromSolutionFile(slnProjects) {
        for (const project of slnProjects) {
            try {
                const parsed = this.parseProject(project, pathUtils.parse(this._filePath).dir);
                if (!parsed.csprojPath.endsWith('.csproj')) {
                    loglevel_1.default.debug('Skipping a project "%s", since it doesn\'t have a csproj file path.', parsed.projectName);
                    continue;
                }
                this.loadProject(parsed.projectName, parsed.csprojPath);
            }
            catch (error) {
                loglevel_1.default.error("Failed parsing and loading project '%s' from solution %s': %s", project, this._filePath, error);
            }
        }
    }
    loadSingleProjectFromDir() {
        const csprojFiles = CommonUtils_1.CommonUtils.listFilesWithExtension(pathUtils.parse(this._filePath).dir, '.csproj');
        if (csprojFiles.length === 1) {
            const projectName = pathUtils.parse(csprojFiles[0]).name;
            this.loadProject(projectName, csprojFiles[0]);
            return;
        }
        loglevel_1.default.warn('Expected only one undeclared project in solution dir. Found: %d', csprojFiles.length);
    }
    /**
     * Loads a project from path.
     * @param projectName
     * @param csprojPath
     */
    loadProject(projectName, csprojPath) {
        // First we will find the project's dependencies source.
        // It can be located in the project's root directory or in
        // a directory with the project name under the solution root.
        const projectRootPath = pathUtils.dirname(csprojPath);
        const projectPathPattern = projectRootPath + pathUtils.sep;
        const projectNamePattern = pathUtils.sep + projectName + pathUtils.sep;
        let dependenciesSource = '';
        this._dependenciesSources.some((source) => {
            if (source.includes(projectPathPattern) || source.includes(projectNamePattern)) {
                dependenciesSource = source;
                return true;
            }
        });
        // If no dependencies source was found, we will skip the current project.
        if (!dependenciesSource) {
            loglevel_1.default.debug('Project dependencies was not found for project: %s', projectName);
        }
        // Create a project builder with an extractor. If successful, add to projects list.
        const proj = Project_1.ProjectBuilder.load(projectName, projectRootPath, dependenciesSource);
        if (proj.extractor) {
            this._projects.push(proj);
        }
    }
    /**
     * Parses the project's details from it's declaration line in the solution file.
     * @param projectLine - declaration line of the project in the solution file.
     * @param solutionDir
     * @returns parsed project object, with the project's name and path.
     */
    parseProject(projectLine, solutionDir) {
        const parsedLine = projectLine.split('=');
        if (parsedLine.length <= 1) {
            throw new Error('Unexpected project line format: ' + projectLine);
        }
        const projectInfo = parsedLine[1].split(',');
        if (projectInfo.length <= 2) {
            throw new Error('Unexpected project information format: ' + parsedLine[1]);
        }
        const projectName = this.removeQuotes(projectInfo[0]);
        // In case we are running on a non-Windows OS,
        // the solution root path and the relative path to csproj file might used different path separators.
        // We want to make sure we will get a valid path after we join both parts,
        // so we will replace the csproj separators.
        projectInfo[1] = CommonUtils_1.CommonUtils.fixSeparatorsToMatchOs(projectInfo[1]);
        const csprojPath = pathUtils.join(solutionDir, this.removeQuotes(projectInfo[1]));
        return new ParsedProject(projectName, csprojPath);
    }
    removeQuotes(value) {
        return value.trim().replace(/^"|"$/g, '');
    }
    /**
     * Parse solution file for projects declarations.
     * @returns array of projects declarations lines.
     */
    parseSlnFile() {
        let projects = [];
        const content = fs.readFileSync(this._filePath).toString();
        const re = /Project\("(.*)(\r\n|\r|\n)EndProject/g;
        const matches = content.match(re);
        if (matches) {
            projects = matches;
        }
        return projects;
    }
}
exports.Solution = Solution;
class ParsedProject {
    constructor(_projectName, _csprojPath) {
        this._projectName = _projectName;
        this._csprojPath = _csprojPath;
    }
    get csprojPath() {
        return this._csprojPath;
    }
    set csprojPath(value) {
        this._csprojPath = value;
    }
    get projectName() {
        return this._projectName;
    }
    set projectName(value) {
        this._projectName = value;
    }
}
//# sourceMappingURL=Solution.js.map